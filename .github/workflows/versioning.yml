---
name: Version & Release

on:
  workflow_call:
    secrets: {}

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # sane default; caller moet óók contents: write zetten

    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: {Validate contents: "write (dry-run push)"}
        shell: bash
        run: |
          set -euo pipefail
          TMP_TAG="__perm_check__$(date +%s)${RANDOM}"
          if git push --dry-run origin HEAD:"refs/tags/${TMP_TAG}" > /tmp/perm_check.log 2>&1; then
            echo "✅ contents: write OK"
          else
            echo "❌ Caller mist waarschijnlijk: permissions: contents: write"
            echo "Voorbeeld:"
            echo "  jobs:"
            echo "    version_and_release:"
            echo "      uses: <org>/<repo>/.github/workflows/versioning.yml@main"
            echo "      permissions:"
            echo "        contents: write"
            echo "Git output:"
            sed -e 's/^/  /' /tmp/perm_check.log || true
            exit 1
          fi

      - name: Get version from VERSION file
        id: version
        shell: bash
        run: |
          if [ ! -f VERSION ]; then
            echo "❌ VERSION file not found!"
            exit 1
          fi
          VERSION="$(tr -d '\n\r ' < VERSION)"
          if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ VERSION must be in format x.y.z"
            exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "TAG=v$VERSION" >> "$GITHUB_ENV"

      - name: Check if tag already exists
        id: check_tag
        shell: bash
        run: |
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Tag ${TAG} already exists. Nothing to do."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Find previous tag
        if: steps.check_tag.outputs.exists == 'false'
        id: prev
        shell: bash
        run: |
          PREV="$(git tag --list 'v*' --sort=-v:refname | head -n1)"
          if [ "$PREV" = "${TAG}" ]; then
            PREV="$(git tag --list 'v*' --sort=-v:refname | sed -n '2p')"
          fi
          echo "prev_tag=$PREV" >> "$GITHUB_OUTPUT"

      - name: Build release notes (grouped & sorted)
        if: steps.check_tag.outputs.exists == 'false'
        shell: bash
        run: |
          set -euo pipefail

          # Bepaal commit-range
          PREV="${{ steps.prev.outputs.prev_tag }}"
          if [ -n "$PREV" ]; then
            RANGE="${PREV}..HEAD"
          else
            RANGE="$(git rev-list --max-parents=0 HEAD)..HEAD"
          fi

          # Haal commits op: HASH \t SHORT \t SUBJECT \t AUTHOR
          # Filter [skip ci] case-insensitive en merges verwijderen
          git log --no-merges --pretty=format:'%H%x09%h%x09%s%x09%an' $RANGE \
            | grep -vi '\[skip ci\]' \
            > /tmp/commits.tsv || true

          # Als er niets is, simpele placeholder
          if [ ! -s /tmp/commits.tsv ]; then
            echo "- No user-visible changes." > release_notes.md
            exit 0
          fi

          # Vooraf gedefinieerde categorievolgorde
          TYPES=("feat" "fix" "perf" "refactor" "docs" "test" "build" "ci" "style" "chore" "revert")
          # Map: type -> bestandsnaam
          declare -A FILES
          for t in "${TYPES[@]}"; do
            FILES["$t"]="/tmp/sect_${t}.lst"
            : > "${FILES[$t]}"
          done
          OTHER="/tmp/sect_other.lst"; : > "$OTHER"

          # Parse regels, bepaal type en ticketnummer (voor sortering)
          # Type: ^type(\(scope\))?:  (bijv. feat(DLP-1234): message)
          # Ticketnummer: eerste getal in de scope of subject (b.v. 1234 uit DLP-1234)
          while IFS=$'\t' read -r HASH SHORT SUBJ AUTH; do
            low="$(printf "%s" "$SUBJ" | awk '{ print tolower($0) }')"
            if [[ "$low" =~ ^([a-z0-9\-]+)(\([^\)]*\))?:[[:space:]]+ ]]; then
              TYPE="${BASH_REMATCH[1]}"
            else
              TYPE="other"
            fi

            # extract eerste nummer (bijv. 1234 uit DLP-1234 of uit de rest van de subject)
            NUM=$(printf "%s" "$SUBJ" | grep -oE '[A-Z]+-[0-9]+' | head -n1 | grep -oE '[0-9]+' || true)
            if [ -z "$NUM" ]; then
              # fallback: zoek willekeurig nummer in subject
              NUM=$(printf "%s" "$SUBJ" | grep -oE '[0-9]+' | head -n1 || true)
            fi
            if [ -z "$NUM" ]; then
              NUM="99999999"  # zonder nummer -> onderaan binnen categorie
            fi

            # Zero-pad voor sortering
            PAD=$(printf "%08d" "$NUM")
            LINE="- ${SUBJ} (${SHORT}) — ${AUTH}"

            # append naar juiste categorie
            if [[ " ${TYPES[*]} " == *" ${TYPE} "* ]]; then
              echo "${PAD}|${LINE}" >> "${FILES[$TYPE]}"
            else
              echo "${PAD}|${LINE}" >> "$OTHER"
            fi
          done < /tmp/commits.tsv

          # Schrijf release_notes.md met secties op volgorde; sorteer binnen sectie op nummer
          : > release_notes.md
          write_section () {
            local header="$1"
            local file="$2"
            if [ -s "$file" ]; then
              echo "### ${header}" >> release_notes.md
              sort -t'|' -k1,1n "$file" | cut -d'|' -f2- >> release_notes.md
              echo "" >> release_notes.md
            fi
          }

          write_section "Features"     "${FILES[feat]}"
          write_section "Fixes"        "${FILES[fix]}"
          write_section "Performance"  "${FILES[perf]}"
          write_section "Refactoring"  "${FILES[refactor]}"
          write_section "Docs"         "${FILES[docs]}"
          write_section "Tests"        "${FILES[test]}"
          write_section "Build"        "${FILES[build]}"
          write_section "CI"           "${FILES[ci]}"
          write_section "Style"        "${FILES[style]}"
          write_section "Chores"       "${FILES[chore]}"
          write_section "Reverts"      "${FILES[revert]}"

          # Alles zonder (herkend) type onderaan
          write_section "Overige"      "$OTHER"

          # Fallback als echt niets geschreven is
          if [ ! -s release_notes.md ]; then
            echo "- No user-visible changes." > release_notes.md
          fi

          echo "---- Release notes ----"
          cat release_notes.md
          echo "-----------------------"

      - name: Create annotated tag
        if: steps.check_tag.outputs.exists == 'false'
        shell: bash
        run: |
          git tag -a "${TAG}" -m "Release ${TAG}"
          git push origin "refs/tags/${TAG}"

      - name: Create GitHub Release
        if: steps.check_tag.outputs.exists == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG }}
          name: ${{ env.TAG }}
          body_path: release_notes.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Nothing to release (tag existed)
        if: steps.check_tag.outputs.exists == 'true'
        run: echo "Release already exists for ${TAG}; skipping."
